#!/usr/bin/env python
# 
# tournament.py -- Implementation of stateless APIs that can be used
# to simulate a tournament that uses the swiss type of competition
# where in players are not eliminated, rather the best scoring player
# wins.
# Author :: Colathur Vijayan ["VJN"]
#


# NOTE :: While the RETURNING Clause which returns the surrogate keys
# generated by the RDBMS is non-standard SQL [in the sense that not all 
# RDBMS's support it], I have used it since it comes in pretty handy
# for writing unit tests, where a user key may not exist. 


import psycopg2


def connect():
    """Returns a database connection to a postgresql database."""
    return psycopg2.connect("dbname=tournament")

def createTournament(tournament_name):
    """Adds a unique tournment name to the tournament database,                 
    with the database auto-creating a unique sequence for each
    tournament.
  
    Args:
      tournament_name: The unique tournament name.
      
    Returns:
      Surrogate Key [tournament_id] of the players table created using 
      the SERIAL data type.  
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """insert into tournaments(tournament_name) values(%s) 
    returning tournament_id"""
    cur.execute(query_str, [tournament_name])
    row = cur.fetchone()
    conn.commit()
    conn.close()
    return row[0]

def registerPlayer(player_name):
    """Registers a player to the player database. Note that not all 
    registered players play in all tournaments. This function basically
    create a pool of players who are in turn chosen players to play
    in tournaments. 
  
    Args:
      player_name: The player name [need not be unique].
      
    Returns:
      Surrogate Key [player_id] of the players table created using the 
      SERIAL data type.
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """insert into players(player_name) values(%s) 
    returning player_id"""
    cur.execute(query_str, [player_name] )
    row = cur.fetchone()
    conn.commit()
    conn.close()
    return row[0]
    
def addPlayer2Tournament(player_id, tournament_id):
    """Adds a registered player to a tournament.
  
    Args:
      player_id: The unique id of a player.
      tournament_name : The unique id of the tournament in which the 
      player plays.
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """insert into tournament_roster(player_id,tournament_id) 
    values(%s, %s)"""
    cur.execute(query_str, [player_id, tournament_id] )
    conn.commit()
    conn.close()
    
def deleteMatches(tournament_id):
    """Remove all the match records for a specific tournament. The tournament 
    and its players remain, but the match records will be gone.
    
    Args:
      tournament_id : The unique id of the tournament.
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """delete from matches where tournament_id = %s"""
    cur.execute(query_str, [tournament_id] )
    conn.commit()
    conn.close()
    
def delPlayersfromTournament(tournament_id):
    """Remove all the players and their match records for a specific 
    tournament. The tournament name remains, everything else about it
    is gone.
    
    
    Args:
      tournament_id : The unique id of the tournament.
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """delete from matches where tournament_id = %s"""
    cur.execute(query_str, [tournament_id] )
    query_str = """delete from tournament_roster where tournament_id = %s"""
    cur.execute(query_str, [tournament_id] )
    conn.commit()
    conn.close()

def deleteTournament(tournament_id):
    """Remove all the records [tournament name, its players and matches 
    for a specific tournament. The entire tournament is gone.
    
    Args:
      tournament_id : The unique id of the tournament.
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """delete from matches where tournament_id = %s"""
    cur.execute(query_str, [tournament_id] )
    query_str = """delete from tournament_roster where tournament_id = %s"""
    cur.execute(query_str, [tournament_id] )
    query_str = """delete from tournaments where tournament_id = %s"""
    cur.execute(query_str, [tournament_id] )
    conn.commit()
    conn.close()


def countPlayers(tournament_id):
    """Returns the number of players currently added to a tournament.
    
    Args:
      tournament_id : The unique id of the tournament.
    
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """select count(player_id) from tournament_roster 
    where tournament_id = %s"""
    cur.execute(query_str, [tournament_id])
    row = cur.fetchone()
    conn.close()
    return row[0] 

def playerStandings(tournament_id):
    """Returns a list of the players and their win records, sorted by wins
    for a specific tournament.

    The first entry in the list should be the player in first place, or a 
    player tied for first place if there is currently a tie.

    Returns:
      A list of tuples, each of which contains (id, name, wins, matches):
        id: the player's unique id (assigned by the database)
        name: the player's full name (as registered)
        wins: the number of matches the player has won
        matches: the number of matches the player has played
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """select id, name, sum(win) as wins, 
    sum(win + loss) as matches 
    from (select B.player_id as id, B.player_name as name, 
    CASE WHEN B.player_id = C.winner_id THEN 1 ELSE 0 END as win, 
    CASE WHEN B.player_id = C.loser_id THEN 1 ELSE 0 END as loss, 
    CASE WHEN C.winner_id IS NULL and C.loser_id IS NULL 
    THEN 1 ELSE 0 END as neither 
    from tournament_roster A INNER JOIN players B 
    ON (A.player_id = B.player_id) 
    LEFT OUTER JOIN matches C ON (A.tournament_id = C.tournament_id and 
    (A.player_id = C.winner_id) or (A.player_id = C.loser_id)) 
    where A.tournament_id = %s ) as derivedTable group by id, name
    order by wins, id desc"""
    cur.execute(query_str,[tournament_id])
    row = cur.fetchall()
    conn.close()
    return row

def reportMatch(tournament_id, winner_id, loser_id):
    """Records the outcome of a single match between two players
    in a specific tournament.

    Args:
      tourament_id: the id of the tournament in which the winner 
      and loser play
      winner_id:  the id number of the player who won
      loser_id:  the id number of the player who lost
      
    Returns:
      Surrogate Key [match_id] of the matches table created using the SERIAL 
      data type.  
    """
    conn = connect()
    cur = conn.cursor()
    query_str = """insert into matches(tournament_id,winner_id,loser_id) 
    values(%s, %s, %s) returning match_id"""
    cur.execute(query_str, [tournament_id, winner_id, loser_id])
    row = cur.fetchone()
    conn.commit()
    conn.close()
    return row[0] 
 
def swissPairings(tournament_id):
    """Returns a list of pairs of players for the next round of a match
    for a specific tournament.
  
    Assuming that there are an even number of players registered, each player
    appears exactly once in the pairings.  Each player is paired with another
    player with an equal or nearly-equal win record, that is, a player 
    adjacent to him or her in the standings.
  
    Returns:
      A list of tuples, each of which contains (id1, name1, id2, name2)
        id1: the first player's unique id
        name1: the first player's name
        id2: the second player's unique id
        name2: the second player's name
    """
    # if number of players is ODD remove first player in list 
    # [i.e., the one with the highest score just to make sure to include
    # any player in current round, that might not have played in the 
    # previous round
    standings = playerStandings(tournament_id)
    if(countPlayers(tournament_id) % 2 == 1):
        del standings[0]
    pairings = [] 
    temp = []
    
    # Considering that tuples are immutable and cannot be extended or 
    # overwritten, we use a list as opposed to a tuple for temp
    for i in range(len(standings)):
        if ( i % 2 == 0 ):
            temp = [standings[i][0], standings[i][1]]
	else:
	    temp.append(standings[i][0]) 
	    temp.append(standings[i][1])
            pairings.append((temp[0], temp[1],temp[2], temp[3]))
    return pairings